#!/usr/bin/env python3
"""Summarise per-participant biweekly survey compliance.

The Gauteng Wellbeing Mapper protocol compensates participants for up to
12 biweekly survey periods (â‰ˆ six months) beginning on their consent date.
This tool inspects the structured CSV outputs generated by
``structure_tools/generate_survey_csvs.py`` and produces a summary that
counts, for every participant, how many of those 12 periods include at
least one qualifying submission.

Rules implemented here:
    * Period 1 begins on ``consent.submitted_at`` and covers the first 14
      days. Each subsequent period covers the next 14-day block.
    * The initial survey automatically satisfies Period 1.
    * Additional biweekly submissions are counted at most once per period;
      multiple responses inside a single period still count as a single
      fulfilled period.

Two artefacts are written:
    1. ``biweekly_period_summary.csv`` â€“ machine-readable table with per
       participant statistics.
    2. ``biweekly_period_summary.md`` â€“ Markdown report with the same core
       data, easier for sharing with colleagues.

Both artefacts live alongside the structured CSVs for the current run.
Optionally, ``--latest-output`` can be provided to keep an always-fresh copy
outside the timestamped folder.
"""

from __future__ import annotations

import argparse
from dataclasses import dataclass
from datetime import timedelta
from pathlib import Path
from typing import Dict, List, Optional

import pandas as pd


TOTAL_PERIODS_DEFAULT = 12
PERIOD_DAYS_DEFAULT = 14


@dataclass
class ParticipantPeriods:
    """Calculated period fulfilment details."""

    participant_uuid: str
    participant_code: str
    consent_date: pd.Timestamp
    initial_date: Optional[pd.Timestamp]
    biweekly_dates: List[pd.Timestamp]
    period_flags: List[bool]

    @property
    def completed_periods(self) -> int:
        return sum(self.period_flags)

    @property
    def completed_indices(self) -> List[int]:
        return [idx + 1 for idx, hit in enumerate(self.period_flags) if hit]

    @property
    def missing_indices(self) -> List[int]:
        return [idx + 1 for idx, hit in enumerate(self.period_flags) if not hit]

    @property
    def last_submission(self) -> Optional[pd.Timestamp]:
        all_dates = [dt for dt in self.biweekly_dates if pd.notna(dt)]
        if self.initial_date is not None and pd.notna(self.initial_date):
            all_dates.append(self.initial_date)
        return max(all_dates) if all_dates else None


# ---------------------------------------------------------------------------
# Helpers
# ---------------------------------------------------------------------------


def _coerce_datetime(series: pd.Series) -> pd.Series:
    dt = pd.to_datetime(series, errors="coerce", utc=True)
    # Ensure tz-aware values; if parse failed we leave NaT
    return dt


def _first_valid_string(series: pd.Series) -> str:
    for value in series:
        if isinstance(value, str) and value.strip():
            return value.strip()
    return ""


def _format_ts(value: Optional[pd.Timestamp]) -> str:
    if value is None or pd.isna(value):
        return ""
    if value.tzinfo is None:
        value = value.tz_localize("UTC")
    else:
        value = value.tz_convert("UTC")
    return value.isoformat().replace("+00:00", "Z")


def _load_csv(path: Path, required: bool = True) -> pd.DataFrame:
    if not path.exists():
        if required:
            raise FileNotFoundError(f"Required file not found: {path}")
        return pd.DataFrame()
    return pd.read_csv(path)


# ---------------------------------------------------------------------------
# Core logic
# ---------------------------------------------------------------------------


def compute_participant_periods(
    structured_dir: Path,
    total_periods: int,
    period_days: int,
) -> List[ParticipantPeriods]:
    consent_df = _load_csv(structured_dir / "consent.csv")
    if consent_df.empty:
        return []

    consent_df["submitted_at"] = _coerce_datetime(consent_df.get("submitted_at"))
    consent_df = consent_df.dropna(subset=["participant_uuid", "submitted_at"])

    consent_meta = (
        consent_df.sort_values("submitted_at")
        .groupby("participant_uuid")
        .agg(
            consent_date=("submitted_at", "first"),
            participant_code=("participant_signature", _first_valid_string),
        )
    )

    initial_df = _load_csv(structured_dir / "initial_survey.csv", required=False)
    if not initial_df.empty:
        initial_df["submitted_at"] = _coerce_datetime(initial_df.get("submitted_at"))
        initial_meta = (
            initial_df.dropna(subset=["participant_uuid", "submitted_at"])
            .sort_values("submitted_at")
            .groupby("participant_uuid")
            .agg(initial_date=("submitted_at", "first"))
        )
    else:
        initial_meta = pd.DataFrame(columns=["initial_date"])

    biweekly_df = _load_csv(structured_dir / "biweekly_survey.csv", required=False)
    if not biweekly_df.empty:
        biweekly_df["submitted_at"] = _coerce_datetime(biweekly_df.get("submitted_at"))
        biweekly_df = biweekly_df.dropna(subset=["participant_uuid", "submitted_at"])
    else:
        biweekly_df = pd.DataFrame(columns=["participant_uuid", "submitted_at"])

    period_length = timedelta(days=period_days)

    results: List[ParticipantPeriods] = []

    for participant_uuid, consent_row in consent_meta.iterrows():
        consent_date = consent_row["consent_date"]
        if pd.isna(consent_date):
            continue

        participant_code = consent_row["participant_code"] or participant_uuid
        initial_date = None
        if participant_uuid in initial_meta.index:
            initial_candidate = initial_meta.loc[participant_uuid, "initial_date"]
            if not pd.isna(initial_candidate):
                initial_date = initial_candidate

        participant_biweekly = []
        if not biweekly_df.empty:
            submissions = biweekly_df[biweekly_df["participant_uuid"] == participant_uuid][
                "submitted_at"
            ].tolist()
            participant_biweekly = [ts for ts in submissions if not pd.isna(ts)]
            participant_biweekly.sort()

        period_flags: List[bool] = [False] * total_periods

        # Initial survey satisfies Period 1 if present
        if initial_date is not None:
            period_flags[0] = True

        for submission in participant_biweekly:
            if pd.isna(submission):
                continue
            delta = submission - consent_date
            if delta.total_seconds() < 0:
                continue  # ignore submissions before consent
            period_index = int(delta // period_length)
            if 0 <= period_index < total_periods:
                period_flags[period_index] = True

        results.append(
            ParticipantPeriods(
                participant_uuid=participant_uuid,
                participant_code=participant_code,
                consent_date=consent_date,
                initial_date=initial_date,
                biweekly_dates=participant_biweekly,
                period_flags=period_flags,
            )
        )

    return results


def build_summary_frame(records: List[ParticipantPeriods], total_periods: int) -> pd.DataFrame:
    rows: List[Dict[str, object]] = []
    for record in records:
        completed = record.completed_periods
        completed_indices = record.completed_indices
        missing_indices = record.missing_indices
        last_submission = record.last_submission

        rows.append(
            {
                "participant_code": record.participant_code,
                "participant_uuid": record.participant_uuid,
                "consent_date": _format_ts(record.consent_date),
                "initial_submission": _format_ts(record.initial_date),
                "periods_completed": completed,
                "total_periods": total_periods,
                "completed_periods": ", ".join(f"P{idx}" for idx in completed_indices),
                "missing_periods": ", ".join(f"P{idx}" for idx in missing_indices),
                "last_submission": _format_ts(last_submission),
            }
        )

    frame = pd.DataFrame(rows)
    if not frame.empty:
        frame = frame.sort_values(
            by=["participant_code", "consent_date"],
            na_position="last",
        ).reset_index(drop=True)
    return frame


def _md_escape(value: object) -> str:
    text = "" if value is None else str(value)
    return text.replace("|", "\\|")


def write_markdown_report(df: pd.DataFrame, path: Path) -> None:
    path.parent.mkdir(parents=True, exist_ok=True)
    with path.open("w", encoding="utf-8", newline="") as handle:
        handle.write("# Biweekly Participation Summary\n\n")
        handle.write(
            "This report lists how many of the scheduled biweekly periods were\n"
            "completed by each participant during the latest pipeline run.\n\n"
        )
        if df.empty:
            handle.write("_No consented participants were found in this dataset._\n")
            return

        headers = [
            "Participant Code",
            "UUID",
            "Consent",
            "Completed",
            "Target",
            "Covered",
            "Missing",
            "Last Submission",
        ]
        handle.write("| " + " | ".join(headers) + " |\n")
        handle.write("| " + " | ".join(["---"] * len(headers)) + " |\n")

        for _, row in df.iterrows():
            values = [
                _md_escape(row.get("participant_code")),
                _md_escape(row.get("participant_uuid")),
                _md_escape(row.get("consent_date")),
                _md_escape(row.get("periods_completed")),
                _md_escape(row.get("total_periods")),
                _md_escape(row.get("completed_periods")),
                _md_escape(row.get("missing_periods")),
                _md_escape(row.get("last_submission")),
            ]
            handle.write("| " + " | ".join(values) + " |\n")


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Summarise biweekly survey compliance")
    parser.add_argument(
        "--input",
        required=True,
        help="Directory containing structured CSVs (consent.csv, initial_survey.csv, biweekly_survey.csv)",
    )
    parser.add_argument(
        "--output",
        required=True,
        help="Directory where the summary artefacts should be written",
    )
    parser.add_argument(
        "--total-periods",
        type=int,
        default=TOTAL_PERIODS_DEFAULT,
        help="Number of biweekly periods to evaluate (default: 12)",
    )
    parser.add_argument(
        "--period-days",
        type=int,
        default=PERIOD_DAYS_DEFAULT,
        help="Length of each period in days (default: 14)",
    )
    parser.add_argument(
        "--latest-output",
        help="Optional path to also write the CSV summary (kept up to date across runs)",
    )
    return parser.parse_args()


def main() -> int:
    args = parse_args()
    structured_dir = Path(args.input).resolve()
    output_dir = Path(args.output).resolve()
    output_dir.mkdir(parents=True, exist_ok=True)

    records = compute_participant_periods(
        structured_dir=structured_dir,
        total_periods=args.total_periods,
        period_days=args.period_days,
    )

    summary_df = build_summary_frame(records, total_periods=args.total_periods)

    csv_path = output_dir / "biweekly_period_summary.csv"
    summary_df.to_csv(csv_path, index=False)

    if args.latest_output:
        latest_path = Path(args.latest_output).resolve()
        latest_path.parent.mkdir(parents=True, exist_ok=True)
        summary_df.to_csv(latest_path, index=False)

    markdown_path = output_dir / "biweekly_period_summary.md"
    write_markdown_report(summary_df, markdown_path)

    print(f"ğŸ“„ Wrote CSV summary to: {csv_path}")
    if args.latest_output:
        print(f"ğŸ” Updated rolling summary at: {args.latest_output}")
    print(f"ğŸ“ Wrote Markdown report to: {markdown_path}")

    return 0


if __name__ == "__main__":
    raise SystemExit(main())
